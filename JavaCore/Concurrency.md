### Многопоточность в действии:

Если давать множеству потоков изменять состояние одной переменной без правильной
синхронизации, это приведет к некорректной работе программы.Но этого можно избежать с
помощью:

* Не давать доступ к состоянию переменной через потоки
* Сделать состояние переменной неизменяемым
* Использовать синхронизацию

Правильная реализация инкапсуляции помогает нам достичь thread-safe (потокобезопасные)
классы. 
Но иногда такие понятия как "абстракция" и "инкапсуляция" не в ладах с производительностью
или обратной совместимостью.

Определение потокобезопасного класса:
Класс называется потокобезопасным тогда,когда при доступе из нескольких потоков 
он ведет себя корректно независимо от чередования этих потоков рантаймом.

Пример с сервлетом без состояния
~~~
@ThreadSafe
public class StatelessFactorizer implements Servlet {
public void service(ServletRequest req, ServletResponse resp) {
BigInteger i = extractFromRequest(req);
BigInteger[] factors = factor(i);
encodeIntoResponse(resp, factors);
}
}
~~~
Такой сервлет как и большинство сервлетов не имеет состояния(нет полей,и ссылок на другие классы)
Переходное состояние для конкретного вычисления существует исключительно в локальных переменных
которые в свою очередь хранятся в стеке потока и доступны только исполняющему потоку.

! Один поток обращающийся к StatelessFactorizer не может влиять на результат другого 
потока который обращается к тому же StatelessFactorizer,все потому что два потока не разделяют
состояние,как если бы они обращались к разным экземплярам

Из выше сказанного можно сделать вывод,что объекты без состояния всегда thread-safe!

Теперь приведем пример потоконебезопасного класса

~~~
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
private long count = 0;
public long getCount() { return count; }
public void service(ServletRequest req, ServletResponse resp) {
BigInteger i = extractFromRequest(req);
BigInteger[] factors = factor(i);
++count;
encodeIntoResponse(resp, factors);
}
}
~~~
Данный класс не является потокобезопасным т.к операции ++count она не атомарна(не делима),
а представляет собой последовательность из 3‑х операций:получения текущего значения ->
прибавления к нему единицы -> и записи нового значения обратно(read->modify->write)

Вот какая ситуация может произойти если два потока попытаются увеличить значение без 
какой-либо синхронизации:
Если счетчик инициализирован как 9,по неудачному стечению обстоятельств каждый из потоков
считает значение 9 и добавит к нему единицу,и в конечном итоге установят значение как 10.
Как результат наш счетчик будет постоянно оставить на единицу.
