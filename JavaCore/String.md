### Что такое класс String и какие есть особенности класса String?

* Класс String представляет из себя строку(Но если открыть исходники класс String
  можно заметить что строка представлена в виде массива байт

~~~
private final byte[] value;
~~~

до 9 java это был массив char

~~~
private final char[] value;
~~~

зачем это было сделано можно посмотреть в вопросе "Как устроенны компактные строки в Java 9 и сжатие строк в Java 6?"

* Это неизменяемый (immutable) и финализированный(не может иметь потомков) тип данных
* Можно использовать оператор "+" для конкатенации строк
* С 7й версии java строки можно использовать в конструкции switch
* Благодаря своей неизменяемости, объекты класса String являются потокобезопасными
* Каждый объект в java может быть преобразован в строку методом toString()

### Что такое String Pool(Пул строк) и как он работает?

Класс String является наиболее часто используемым классом.Следовательно, огромное
количество объектов лежащих в heap являются объектами типа String и так же, большинство
этих объектов имеют дубликаты

Экземпляр класса String хранится в памяти, именуемой куча (heap), но есть некоторые нюансы. Если строка, созданная при
помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый литерал, уже хранится в
специальном месте кучи — в так называемом пуле строк (string pool). В нем сохраняются исключительно уникальные значения
строковых литералов, а не все строки подряд. Процесс помещения строк в пул называется интернирование (от англ.
interning).

Когда мы объявляем переменную типа String и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там
такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий
адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а
ссылка на нее возвращена и присвоена переменной.

~~~

public class StringExampleOne {

    public static void main(String[] args) {
        String str1 = "str";
        String str2 = "str";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
~~~

Результат будет:

~~~
Строка 1 равна строке 2? true
~~~

### Что выведет следующий код?

~~~
public class StringExampleThree {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = "Top" + str2;

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
} 
~~~

Ответ:Строка 1 равна строке 2? false.

Причиной получения false является то, что интернирование происходит не во время работы приложения (runtime), а во время
компиляции. А т.к. значение строки str3 вычисляется во время выполнения приложения, то на этапе компиляции оно не
известно и потому, не добавляется в пул строк.

### Как происходит создание строк с помощью конструктора?

Когда мы создаем экземпляр класса String с помощью оператора new, компилятор размещает строки в куче. При этом каждая
строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче
или в пуле строк.

### Расскажите про метод intern()

Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в
пуле.

~~~
public class StringExampleFive {

    public static void main(String[] args) {
        String str1 = "str";
        String str2 = "str";
        String str3 = (new String("str")).intern();
        String str4 = (new String("str")).intern();

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
~~~

В данном случае все 3 варианта будут true.

### Как устроенны компактные строки в Java 9 и сжатие строк в Java 6?

В jdk 6 была представлена новая опция для JVM:

~~~
-XX: + UseCompressedStrings
~~~

Когда эта опция включена, строки хранятся не как char[],а как
byte[],что экономит много памяти. Однако эта опция была в конечном итоге
удалена в JDK 7 из-за непредсказуемых последствий для производительности.

В Java 9 вернули концепцию компактных строк.Это означает, что всякий раз,
когда мы создаем строку символы которой могут быть представлены с использованием
одного байта – в LATIN-1, то для хранения строк будет использоваться байтовый массив.
Но, если какой-либо символ требует более 8 бит для своего представления, то каждый
символы сроки будет занимать два байта (UTF-16).

Как будут работать все операции со строками? Как будут различаться кодировки строк?
Для решения этой проблемы было внесено ещё одно изменение во внутреннюю реализацию
String. Теперь данный класс содержит поле private final byte coder, которое хранит
эту информацию.

~~~
private final byte coder;
~~~

При этом идентификатор поддерживает следующие значения:

~~~
static final byte LATIN1 = 0;
static final byte UTF16 = 1;
~~~

Большинство методов класса String теперь проверяют поле coder и в зависимости от
его значения использую разную реализацию:

~~~

public int indexOf(int ch, int fromIndex) {
    return isLatin1()
            ? StringLatin1.indexOf(value, ch, fromIndex)
            : StringUTF16.indexOf(value, ch, fromIndex);
} 
 
private boolean isLatin1() {
    return COMPACT_STRINGS && coder == LATIN1;
}
~~~

Для отключения компактных строк существует опция:

~~~
+XX:-CompactStrings
~~~

В реализации класса String в Java 9 длина вычисляется так:

~~~
public int length () {
     return value.length >> coder;
}
~~~

Если строка содержит только LATIN-1, значение кодировщика будет равно 0, поэтому
длина строки будет равна длине байтового массива.
Если строка представлена в виде UTF-16, то значение кодировщика будет равно 1, и,
следовательно, длина будет вдвое меньше размера фактического байтового массива.

### Compact Strings vs. Compressed String

В Compressed Strings в JDK 6 основной проблемой было то, что конструктор String принимал в
качестве аргумента только массив символов char[] не смотря на то, что
многие операции со String зависят от представления char[], а не от байтового массива.
Из-за этого приходилось производить распаковку, что сказывалось на производительности.
Обратите внимание, что в случае Compact String содержание дополнительного поля coder
также может увеличить нагрузку. Чтобы снизить «стоимость» кодера и распаковку байтов
в символы (в случае представления UTF-16), некоторые методы являются встроенными, и
код ASM, сгенерированный компилятором JIT, также был улучшен.

Эти изменение привели к некоторым неожиданным результатам. LATIN-1 indexOf(String)
вызывает встроенный метод, тогда как indexOf(char) — нет. В случае UTF-16 оба эти метода вызывают встроенный метод. Эта
проблема касается только строки LATIN-1 и будет исправлена в будущих выпусках.
Таким образом, с точки зрения производительности, компактные строки Compact Strings лучше,
чем сжатые строки Compressed Strings.
Чтобы узнать, сколько памяти сохранено с помощью Compact Strings, были проанализированы
различные дампы кучи (heap) Java-приложений. И, хотя результаты сильно зависели от
конкретных приложений, общие улучшения были почти всегда значительными.

### Как возможно создать объект класса String?

Создать объект класса String можно двумя способами: при помощи строкового литерала и конструктора.
Первый способ, а он является рекомендуемым, удобен и прост. Под строковым литералом понимается последовательность
символов, заключенных в двойные кавычки

~~~
String stringLiteral = "Str";
~~~

Класс String имеет в своем распоряжении множество конструкторов, которые могут принимать на вход данные разного типа.
Например, строковый литерал:

~~~
String stringViaConstructor = new String("Str");
~~~

или массив символов:

~~~
char[] chars = { 'T', 'o', 'p', 'J', 'a', 'v', 'a' };
String str = new String(chars);
~~~

### Каким образом можно конвертировать примитивный тип в строку?

Можно использовать статический метод класса String valueOf().Например:

~~~
String str = String.valueOf(2);
~~~

### Почему строка является популярным ключом в HashMap в Java?

Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при
дальнейшем использовании. Поэтому в качестве ключа HashMap они будут обрабатываться быстрее.

### Можно ли использовать строки в конструкции switch?

Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. При этом:

* участвующие строки чувствительны к регистру;
* используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание
  NullPointerException стоит предусмотреть проверку на null.
* согласно документации, Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в
  конструкции switch, чем для сцепленных условий if-else.

### Какая основная разница между String, StringBuffer, StringBuilder?

* Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его
  созданием нового экземпляра.

* Класс StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать
  содержимое.

* Класс StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не
  синхронизирован и поэтому его методы выполняются значительно быстрей.